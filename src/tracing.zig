const std = @import("std");
const builtin = @import("builtin");

// These are generated by the build script and can be set on the command line using -Doption...
const build_options = @import("build_options");

pub const Scope = enum {
    codec,
    // Add more scopes as needed
};

inline fn scopeEnabled(comptime scope: Scope) bool {
    for (build_options.enable_tracing_scopes) |scopes| {
        return std.mem.eql(u8, scopes, @tagName(scope));
    }
    return false;
}

inline fn sourceLocationEnabled(comptime loc: std.builtin.SourceLocation) bool {
    const mapped_loc = comptime mapSourceLocation(loc);
    for (build_options.enable_tracing_source_location) |loc_pattern| {
        if (std.mem.indexOf(u8, mapped_loc, loc_pattern) != null) {
            return true;
        }
    }
    return false;
}

fn mapSourceLocation(loc: std.builtin.SourceLocation) []const u8 {
    var parts = std.mem.splitBackwardsSequence(u8, loc.file, "src/");
    const relative_path = if (parts.next()) |path| path else loc.file;
    return std.fmt.comptimePrint("{s}:{s}:{d}", .{
        relative_path,
        loc.fn_name,
        loc.line,
    });
}

// pub const SourceLocation = struct {
//     /// The name chosen when compiling. Not a file path.
//     module: [:0]const u8,
//     /// Relative to the root directory of its module.
//     file: [:0]const u8,
//     fn_name: [:0]const u8,
//     line: u32,
//     column: u32,
// };
pub inline fn scp(comptime scope: Scope, comptime fmt: []const u8, args: anytype) void {
    if (comptime scopeEnabled(scope)) {
        std.debug.print("[trace][" ++ @tagName(scope) ++ "] " ++ fmt ++ "\n", args);
    }
}

pub inline fn src(comptime loc: std.builtin.SourceLocation, comptime fmt: []const u8, args: anytype) void {
    if (comptime sourceLocationEnabled(loc)) {
        const mapped_loc = comptime mapSourceLocation(loc);
        std.debug.print("[trace][{s}] " ++ fmt ++ "\n", .{mapped_loc} ++ args);
    }
}

// std.debug.print("Tracy enabled: {}\n", .{build_options.enable_tracy})
